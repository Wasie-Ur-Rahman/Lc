/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as h from "react";
import m from "prop-types";
import B from "../common/DropDownBase.mjs";
import { Keys as I, validatePackage as ie, svgIconPropType as oe, canUseDOM as R, classNames as w, IconWrap as ae, createPropsContext as ne, withIdHOC as le, withPropsContext as re, kendoThemeMaps as pe } from "@progress/kendo-react-common";
import { FloatingLabel as de } from "@progress/kendo-react-labels";
import { getPlainDataDuplicates as he, getFilteredData as y, areSame as C, getItemValue as D, isPresent as S, getItemIndexByText as A, suggestValue as ce, itemIndexStartsWith as K } from "../common/utils.mjs";
import ue from "../common/SearchBar.mjs";
import ge from "../common/ListContainer.mjs";
import me from "../common/List.mjs";
import ve from "../common/ListFilter.mjs";
import z from "../common/GroupStickyHeader.mjs";
import { packageMetadata as fe } from "../package-metadata.mjs";
import be from "../common/ClearButton.mjs";
import { Button as H } from "@progress/kendo-react-buttons";
import { caretAltDownIcon as xe, xIcon as Ie } from "@progress/kendo-svg-icons";
import { comboArrowBtnAriaLabelExpand as q, messages as $, comboArrowBtnAriaLabelCollapse as G } from "../messages/index.mjs";
import { provideLocalizationService as U } from "@progress/kendo-react-intl";
import { ActionSheet as ye, ActionSheetHeader as ke, ActionSheetContent as Se } from "@progress/kendo-react-layout";
import { MOBILE_MEDIUM_DEVISE as W, MOBILE_SMALL_DEVISE as j } from "../common/constants.mjs";
import Y from "../common/withCustomComponent.mjs";
const Ce = "Please enter a valid value!", { sizeMap: O, roundedMap: De } = pe, E = class E extends h.Component {
  constructor(s) {
    super(s), this.state = {}, this.base = new B(this), this._element = null, this._suggested = "", this._skipBlur = !1, this._input = null, this._adaptiveFilterInput = null, this.itemHeight = 0, this.duplicates = [], this.hasDuplicates = !1, this.focus = () => {
      this._input && this._input.focus();
    }, this.checkForDuplicatePlainTextRecords = () => {
      const e = this.props.textField !== void 0, t = this.props.dataItemKey !== void 0;
      if (this.props.data && this.props.data.length > 0 && !e && !t) {
        const o = this.props.data;
        this.duplicates = he(o), this.hasDuplicates = this.duplicates.length > 0;
      }
    }, this.handleItemSelect = (e, t) => {
      const { virtual: o, dataItemKey: n } = this.props, l = y(this.props), a = o ? o.skip : 0, r = l[e - a], p = this.hasDuplicates || !C(r, this.value, n);
      this.triggerOnChange(r, t), this.state.text !== void 0 && (t.data.text = void 0), p && this.base.triggerPageChangeCornerItems(r, t);
    }, this.onPopupOpened = () => {
      setTimeout(() => {
        this.mobileMode && this._adaptiveFilterInput && (this._skipBlur = !0, this._adaptiveFilterInput.focus(), this._skipBlur = !1);
      }, 300);
    }, this.componentRef = (e) => {
      this._element = e, this.base.wrapper = e;
    }, this.toggleBtnClick = (e) => {
      const { skipDisabledItems: t, textField: o } = this.props, n = y(this.props), l = this.getFocusedIndex(), a = this.getCurrentValueDisabledStatus(o, n, l), r = this.props.opened !== void 0 ? this.props.opened : this.state.opened, p = this.base.initState();
      if (p.syntheticEvent = e, !t && o && a && this.clearValueOnToggleBtnClick(e), this.base.togglePopup(p), !r && this.mobileMode) {
        const i = this.props.adaptiveFilter !== void 0 ? this.props.adaptiveFilter : this.state.text || null;
        this.base.filterChanged(i, p);
      }
      this.applyState(p);
    }, this.closeOpenedApplyStateNonMobileMode = (e, t) => {
      t && !this.mobileMode && this.base.togglePopup(e);
    }, this.renderMobileListFilter = () => {
      const e = this.props.adaptiveFilter !== void 0 ? this.props.adaptiveFilter : this.state.text, t = D(this.value, this.props.textField), o = S(e) ? e : t;
      return /* @__PURE__ */ h.createElement(
        ve,
        {
          value: o,
          ref: (n) => this._adaptiveFilterInput = n && n.element,
          onChange: this.handleMobileFilterChange,
          onKeyDown: this.onInputKeyDown,
          size: "large",
          rounded: this.props.rounded,
          fillMode: this.props.fillMode
        }
      );
    }, this.handleMobileFilterChange = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e.syntheticEvent, t.data.text = e.target.value, this.base.filterChanged(e.target.value, t), this.applyState(t);
    }, this.onScroll = (e) => {
      const { vs: t, list: o } = this.base;
      t.scrollHandler(e);
      const { groupField: n } = this.props;
      let l = y(this.props);
      if (!n || !l.length)
        return;
      const a = this.itemHeight = this.itemHeight || (t.enabled ? t.itemHeight : o ? o.children[0].offsetHeight : 0), p = e.target.scrollTop - t.skip * a;
      this.props.groupMode === "modern" && (l = this.base.getGroupedDataModernMode(l, n));
      let i = l[0][n];
      for (let c = 1; c < l.length && !(a * c > p); c++)
        l[c] && l[c][n] && (i = l[c][n]);
      i !== this.state.group && (this.setState({
        group: i
      }), this.props.onGroupScroll && this.props.onGroupScroll.call(void 0, { group: i }));
    }, this.handleItemClick = (e, t) => {
      this.navigationIndex = e, this.base.handleItemClick(e, t), this._valueDuringOnChange = void 0;
    }, this.handleBlur = (e) => {
      if (this.state.focused && !this._skipBlur) {
        const t = this.base.initState(), { textField: o } = this.props, n = y(this.props), l = this.getFocusedIndex(), r = !(l === -1) && this.getCurrentValueDisabledStatus(o, n, l);
        t.data.focused = !1, t.events.push({ type: "onBlur" }), t.syntheticEvent = e, o && r && this.clearValueOnBlur(e), this.applyValueOnRejectSuggestions(e.currentTarget.value, t);
      }
    }, this.onInputClick = (e) => {
      const t = this.props.opened !== void 0 ? this.props.opened : this.state.opened, o = this.props.adaptiveFilter !== void 0 ? this.props.adaptiveFilter : this.state.text || null;
      if (!t && this.mobileMode) {
        const n = this.base.initState();
        n.syntheticEvent = e, this.base.togglePopup(n), this.base.filterChanged(o, n), this.applyState(n);
      }
    }, this.onInputKeyDown = (e) => {
      const { skipDisabledItems: t, textField: o, dataItemKey: n, groupField: l } = this.props, a = y(this.props), r = this.value, p = Math.max(0, a.findIndex((u) => C(u, r, n))), i = e.keyCode, c = this.props.opened !== void 0 ? this.props.opened : this.state.opened, d = this.base.initState();
      if (d.syntheticEvent = e, !e.altKey && (i === I.up || i === I.down)) {
        if (e.preventDefault(), l !== "" && o)
          if (!this.props.skipDisabledItems && c)
            this.onNavigate(d, i);
          else {
            let u = 0;
            if (i === I.down || i === I.right) {
              const g = a.slice(p + 1 < a.length ? p + 1 : p).find((b) => !b.disabled && b[o]);
              u = g && a.findIndex((b) => b[o] === g[o]);
            } else if (i === I.up || i === I.left) {
              let g;
              if (p === 0)
                g = a, u = a.findIndex((b) => !b.disabled && b[o]);
              else {
                g = a.slice(0, p);
                let b = g.pop();
                for (; b && b.disabled; )
                  b = g.pop();
                u = b && a.findIndex((M) => M[o] === b[o]);
              }
            }
            if (u !== void 0) {
              const g = u - p;
              this.onNavigate(d, i, g);
            } else
              u === void 0 && a.findIndex((g) => g[o] === r[o]) === a.length - 1 && this.onNavigate(d, i);
          }
        else if (!this.props.skipDisabledItems && c)
          this.onNavigate(d, i);
        else {
          let u = null;
          if (i === I.down || i === I.right)
            u = a.slice(p + 1).find((g) => !g.disabled);
          else if (i === I.up || i === I.left) {
            const g = a.slice(0, p);
            for (u = g.pop(); u && u.disabled; )
              u = g.pop();
          }
          if (u) {
            const g = u.id - p - 1;
            this.onNavigate(d, i, g);
          } else
            this.onNavigate(d, i);
        }
        this.applyState(d);
      }
      const v = () => {
        e.preventDefault(), this.base.togglePopup(d), this.applyState(d);
      }, x = this.getFocusedIndex(), f = x === -1, k = !f && this.getCurrentValueDisabledStatus(o, a, x);
      c ? i === I.pageUp ? (e.preventDefault(), this.base.scrollPopupByPageSize(-1)) : i === I.pageDown ? (e.preventDefault(), this.base.scrollPopupByPageSize(1)) : e.altKey && i === I.up ? v() : i === I.enter ? (e.preventDefault(), (o && !f && e.currentTarget.value ? a[x][o] : void 0) ? !t && o && k ? this.clearValueOnEnterOrEsc(e) : k || this.applyValueOnEnter(e.currentTarget.value, d) : this.applyValueOnEnter(e.currentTarget.value, d)) : i === I.esc && (!t && o && k && this.clearValueOnEnterOrEsc(e), this.applyValueOnRejectSuggestions(e.currentTarget.value, d)) : !c && i === I.esc ? this.clearValueOnEnterOrEsc(e) : e.altKey && i === I.down && v();
    }, this.inputOnChange = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e;
      const o = this.props.opened !== void 0 ? this.props.opened : this.state.opened, n = e.currentTarget, l = n.value;
      if (this.props.suggest) {
        const a = n.selectionEnd === l.length;
        let r = this.props.filter !== void 0 ? this.props.filter : this.state.text;
        S(r) || (r = D(this.value, this.props.textField) || "");
        const p = r && r === l, i = r && r.length > l.length;
        p || i || !a ? this._suggested = "" : this.suggestValue(l);
      }
      this.props.filter === void 0 && (t.data.text = l), this.state.focusedItem !== void 0 && (t.data.focusedItem = void 0), o || this.base.togglePopup(t), this.base.filterChanged(l, t), this.applyState(t), this.setState({ group: void 0 });
    }, this.clearButtonClick = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.clearValue();
    }, this.clearValueOnEnterOrEsc = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.clearValue();
    }, this.clearValueOnBlur = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.clearValue();
    }, this.clearValueOnToggleBtnClick = (e) => {
      const t = this.base.initState();
      t.syntheticEvent = e, e.stopPropagation(), this.clearValue();
    }, this.setValidity = () => {
      this._input && this._input.setCustomValidity && this._input.setCustomValidity(
        this.validity.valid ? "" : this.props.validationMessage || Ce
      );
    }, ie(fe);
  }
  get _inputId() {
    return this.props.id;
  }
  get document() {
    if (R)
      return this.element && this.element.ownerDocument || document;
  }
  /** @hidden */
  get element() {
    return this._element;
  }
  /**
   * The mobile mode of the ComboBox.
   */
  get mobileMode() {
    return !!(this.state.windowWidth && this.state.windowWidth <= W && this.props.adaptive);
  }
  /**
   * The value of the ComboBox.
   */
  get value() {
    if (this._valueDuringOnChange !== void 0)
      return this._valueDuringOnChange;
    if (this.props.value !== void 0)
      return this.props.value;
    if (this.state.value !== void 0)
      return this.state.value;
    if (this.props.defaultValue !== void 0)
      return this.props.defaultValue;
  }
  /**
   * The index of the selected item.
   */
  get index() {
    const { dataItemKey: s } = this.props, e = y(this.props), t = this.value;
    return e.findIndex((o) => C(o, t, s));
  }
  /**
   * Gets the `name` property of the ComboBox.
   */
  get name() {
    return this.props.name;
  }
  /**
   * Represents the validity state into which the component is set.
   */
  get validity() {
    const s = this.props.validationMessage !== void 0, e = !this.required || this.value !== null && this.value !== "" && this.value !== void 0, t = this.props.valid !== void 0 ? this.props.valid : e;
    return {
      customError: s,
      valid: t,
      valueMissing: this.value === null
    };
  }
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : E.defaultProps.validityStyles;
  }
  /** @hidden */
  get required() {
    return this.props.required !== void 0 ? this.props.required : E.defaultProps.required;
  }
  /** @hidden */
  componentDidUpdate(s, e) {
    var v;
    const { dataItemKey: t, virtual: o, groupField: n = "", textField: l } = this.props, a = y(this.props), r = s.virtual ? s.virtual.total : 0, p = this.props.opened !== void 0 ? this.props.opened : this.state.opened, i = s.opened !== void 0 ? s.opened : e.opened;
    s.data !== a && this.checkForDuplicatePlainTextRecords();
    const c = !i && p, d = this.value;
    if (this._valueOnDidUpdate = d, this.base.didUpdate(), o && o.total !== r)
      this.base.vs.calcScrollElementHeight(), this.base.vs.reset();
    else {
      const x = s.value !== void 0 ? s.value : e.value;
      let f = this.hasDuplicates ? this.navigationIndex || 0 : a.findIndex((u) => C(u, d, t));
      this.props.groupMode === "modern" && l && d && (f = (v = this.base.getGroupedDataModernMode(a, n)) == null ? void 0 : v.map((u) => u[l]).indexOf(d[l]));
      const k = !C(x, d, t);
      c && o ? this.base.scrollToVirtualItem(o, f) : c && !o ? (this.onPopupOpened(), a && a.length !== 0 && this.base.resetGroupStickyHeader(a[0][n], this), this.base.scrollToItem(f)) : (this.hasDuplicates || p && i && d && k) && this.base.scrollToItem(f);
    }
    c && this._input && this._input.focus(), this.setValidity();
  }
  /** @hidden */
  componentDidMount() {
    var s;
    this.observerResize = R && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.base.didMount(), this.setValidity(), (s = this.document) != null && s.body && this.observerResize && this.observerResize.observe(this.document.body), this.checkForDuplicatePlainTextRecords();
  }
  /** @hidden */
  componentWillUnmount() {
    var s;
    (s = this.document) != null && s.body && this.observerResize && this.observerResize.disconnect();
  }
  /** @hidden */
  render() {
    const s = U(this).toLanguageString(q, $[q]), e = U(this).toLanguageString(
      G,
      $[G]
    ), {
      dir: t,
      disabled: o,
      clearButton: n = E.defaultProps.clearButton,
      label: l,
      textField: a,
      adaptive: r,
      className: p,
      style: i,
      loading: c,
      iconClassName: d,
      virtual: v,
      size: x,
      rounded: f,
      fillMode: k,
      opened: u = this.state.opened,
      placeholder: g,
      svgIcon: b
    } = this.props, M = !this.validityStyles || this.validity.valid, _ = this.props.filter !== void 0 ? this.props.filter : this.state.text, J = D(this.value, a), V = S(_) ? _ : J, Q = n && (!!V || S(this.value)), F = this.base.vs, N = this.props.id || this._inputId, P = this.mobileMode;
    F.enabled = v !== void 0, v !== void 0 && (F.skip = v.skip, F.total = v.total, F.pageSize = v.pageSize);
    const [X, Z] = Y(this.props.prefix || h.Fragment), [ee, te] = Y(this.props.suffix || h.Fragment), L = /* @__PURE__ */ h.createElement(h.Fragment, null, /* @__PURE__ */ h.createElement(
      "span",
      {
        className: w(
          "k-combobox k-input",
          {
            [`k-input-${O[x] || x}`]: x,
            [`k-rounded-${De[f] || f}`]: f,
            [`k-input-${k}`]: k,
            "k-invalid": !M,
            "k-loading": c,
            "k-required": this.required,
            "k-disabled": o
          },
          p
        ),
        ref: this.componentRef,
        style: l ? { ...i, width: void 0 } : i,
        dir: t
      },
      this.props.prefix && /* @__PURE__ */ h.createElement(X, { ...Z }),
      this.renderSearchBar(V || "", N, g),
      Q && !c && /* @__PURE__ */ h.createElement(be, { onClick: this.clearButtonClick, key: "clearbutton" }),
      c && /* @__PURE__ */ h.createElement(ae, { className: "k-input-loading-icon", name: "loading", key: "loading" }),
      this.props.suffix && /* @__PURE__ */ h.createElement(ee, { ...te }),
      /* @__PURE__ */ h.createElement(
        H,
        {
          tabIndex: -1,
          type: "button",
          "aria-label": u ? e : s,
          icon: d ? void 0 : "caret-alt-down",
          svgIcon: b || xe,
          iconClass: d,
          size: x,
          fillMode: k,
          rounded: null,
          themeColor: "base",
          className: "k-input-button",
          onClick: this.toggleBtnClick,
          onMouseDown: (se) => se.preventDefault()
        }
      ),
      !P && this.renderListContainer()
    ), P && this.renderAdaptiveListContainer());
    return l ? /* @__PURE__ */ h.createElement(
      de,
      {
        label: l,
        editorId: N,
        editorValue: V,
        editorValid: M,
        editorDisabled: o,
        style: { width: i ? i.width : void 0 },
        children: L
      }
    ) : L;
  }
  /** @hidden */
  onNavigate(s, e, t) {
    const { virtual: o = { skip: 0 } } = this.props, n = y(this.props), l = this.props.filter ? this.props.filter : this.state.text;
    let a = -1, r;
    const p = this.base.vs, i = this.value;
    this._suggested = "";
    const c = this.hasDuplicates && this.duplicates.indexOf(i) !== -1;
    if (a = this.getFocusedIndex(c), a !== -1 && !S(i))
      this.handleItemSelect(a, s);
    else if (l === "")
      this.handleItemSelect(0, s);
    else {
      const d = o.skip + a;
      r = this.base.navigation.navigate({
        keyCode: e,
        current: d,
        max: (p.enabled ? p.total : n.length) - 1,
        min: 0,
        skipItems: t || void 0
      }), r !== void 0 && this.handleItemSelect(r, s);
    }
    this.navigationIndex = r;
  }
  getCurrentValueDisabledStatus(s, e, t) {
    return s && e && e[t] && e[t].disabled;
  }
  applyValueOnEnter(s, e) {
    const { textField: t, allowCustom: o } = this.props, n = y(this.props), l = this.props.opened !== void 0 ? this.props.opened : this.state.opened, r = D(this.value, t) === s ? this.index : A(n, s, t), p = r !== -1;
    let i;
    if (this._suggested = "", p)
      i = n[r];
    else if (o)
      i = t !== void 0 ? { [t]: s } : s;
    else
      return this.selectFocusedItem(s, e);
    this.triggerOnChange(i, e), l && this.base.togglePopup(e), this.props.filter === void 0 && this.state.text !== void 0 && (e.data.text = void 0), this.applyState(e);
  }
  applyValueOnRejectSuggestions(s, e) {
    const { textField: t, allowCustom: o } = this.props, n = y(this.props), l = this.props.opened !== void 0 ? this.props.opened : this.state.opened, a = D(this.value, t);
    if (this._suggested = "", s === a || s === "" && !S(a))
      return this.closeOpenedApplyStateNonMobileMode(e, l), this.applyState(e);
    const r = A(n, s, t, !0), p = r !== -1;
    let i = null;
    p ? i = n[r] : o && (i = s ? t ? { [t]: s } : s : null), this.triggerOnChange(i, e), this.state.text !== void 0 && (e.data.text = void 0, this.base.filterChanged("", e)), this.closeOpenedApplyStateNonMobileMode(e, l), this.applyState(e);
  }
  selectFocusedItem(s, e) {
    const t = this.props.opened !== void 0 ? this.props.opened : this.state.opened, { textField: o, virtual: n = { skip: 0 }, focusedItemIndex: l = K } = this.props, a = y(this.props), r = n.skip, p = s === "" && r === 0 ? 0 : l(a, s, o);
    return p !== -1 ? this.handleItemSelect(p + r, e) : (this.triggerOnChange(null, e), this.state.text !== void 0 && (e.data.text = void 0)), t && this.base.togglePopup(e), this.applyState(e);
  }
  renderAdaptiveListContainer() {
    const { windowWidth: s = 0 } = this.state, { header: e, footer: t, size: o, groupField: n, groupMode: l, list: a, virtual: r, adaptiveTitle: p, groupStickyHeaderItemRender: i } = this.props, c = y(this.props), d = this.props.opened !== void 0 ? this.props.opened : this.state.opened, v = this.base.getAdaptiveAnimation();
    let { group: x } = this.state;
    x === void 0 && n !== void 0 && (x = D(c[0], n));
    const f = {
      navigatable: !1,
      navigatableElements: [],
      expand: d,
      animation: v,
      onClose: (k) => this.toggleBtnClick(k),
      animationStyles: s <= j ? { top: 0, width: "100%", height: "100%" } : void 0,
      className: s <= j ? "k-adaptive-actionsheet k-actionsheet-fullscreen" : "k-adaptive-actionsheet k-actionsheet-bottom k-actionsheet"
    };
    return /* @__PURE__ */ h.createElement(ye, { ...f }, /* @__PURE__ */ h.createElement(ke, null, /* @__PURE__ */ h.createElement("div", { className: "k-actionsheet-titlebar-group k-hbox" }, /* @__PURE__ */ h.createElement("div", { className: "k-actionsheet-title" }, /* @__PURE__ */ h.createElement("div", { className: "k-text-center" }, p), /* @__PURE__ */ h.createElement("div", { className: "k-actionsheet-subtitle k-text-center" })), /* @__PURE__ */ h.createElement("div", { className: "k-actionsheet-actions" }, /* @__PURE__ */ h.createElement(
      H,
      {
        tabIndex: 0,
        "aria-label": "Cancel",
        "aria-disabled": "false",
        type: "button",
        fillMode: "flat",
        themeColor: "base",
        size: "large",
        onClick: this.toggleBtnClick,
        icon: "x",
        svgIcon: Ie
      }
    ))), /* @__PURE__ */ h.createElement("div", { className: "k-actionsheet-titlebar-group k-actionsheet-filter" }, this.renderMobileListFilter())), /* @__PURE__ */ h.createElement(Se, { className: "!k-overflow-hidden" }, /* @__PURE__ */ h.createElement("div", { className: "k-list-container" }, /* @__PURE__ */ h.createElement("div", { className: w(
      {
        "k-list": !a,
        "k-list-lg": !0,
        "k-virtual-list": r,
        "k-data-table": a,
        [`k-table-${O[o] || o}`]: a && o
      }
    ) }, e && /* @__PURE__ */ h.createElement("div", { className: "k-table-header" }, e), !a && x && c.length !== 0 && /* @__PURE__ */ h.createElement(z, { group: x, groupMode: l, render: i }), this.renderList(), t && /* @__PURE__ */ h.createElement("div", { className: "k-list-footer" }, t)))));
  }
  renderListContainer() {
    const s = this.base, { dir: e, header: t, footer: o, groupField: n, groupMode: l, size: a, list: r, virtual: p, groupStickyHeaderItemRender: i } = this.props, c = y(this.props), d = this.props.opened !== void 0 ? this.props.opened : this.state.opened, v = s.getPopupSettings(), x = v.width !== void 0 ? v.width : s.popupWidth;
    let { group: f } = this.state;
    return f === void 0 && n !== void 0 && (f = D(c[0], n)), /* @__PURE__ */ h.createElement(
      ge,
      {
        width: x,
        popupSettings: {
          ...v,
          anchor: v.anchor || this.element,
          show: d,
          popupClass: w(
            v.popupClass,
            "k-list-container",
            "k-combobox-popup"
          )
        },
        dir: e !== void 0 ? e : this.base.dirCalculated,
        itemsCount: [c.length]
      },
      /* @__PURE__ */ h.createElement("div", { className: w(
        {
          "k-list": !r,
          [`k-list-${O[a] || a}`]: !r && a,
          "k-virtual-list": p,
          "k-data-table": r,
          [`k-table-${O[a] || a}`]: r && a
        }
      ) }, t && /* @__PURE__ */ h.createElement("div", { className: "k-table-header" }, t), !r && f && c.length !== 0 && /* @__PURE__ */ h.createElement(z, { group: f, groupMode: l, render: i }), this.renderList(), o && /* @__PURE__ */ h.createElement("div", { className: w(
        {
          "k-list-footer": !this.props.footerClassName
        },
        this.props.footerClassName
      ) }, o))
    );
  }
  renderList() {
    const s = this.base, {
      textField: e,
      dataItemKey: t,
      listNoDataRender: o,
      itemRender: n,
      groupHeaderItemRender: l,
      virtual: a = { skip: 0, total: void 0 }
    } = this.props, r = y(this.props), p = s.getPopupSettings(), i = s.vs, c = a.skip, d = this.props.opened !== void 0 ? this.props.opened : this.state.opened, v = `translateY(${i.translate}px)`, x = d ? this.getFocusedIndex(this.hasDuplicates) : void 0, f = this.props.filter !== void 0 ? this.props.filter : this.state.text, k = D(this.value, e), u = S(f) && f !== k ? null : this.value, g = this.props.list || me;
    return /* @__PURE__ */ h.createElement(
      g,
      {
        id: s.listBoxId,
        virtual: !!a,
        show: d,
        data: r,
        focusedIndex: x,
        value: u,
        textField: e,
        valueField: t,
        groupField: this.props.groupField,
        groupMode: this.props.groupMode,
        isMultiColumn: this.props.isMultiColumn,
        optionsGuid: s.guid,
        hasDuplicates: this.hasDuplicates,
        listRef: (b) => {
          i.list = this.base.list = b, this.itemHeight = 0;
        },
        wrapperStyle: this.state.windowWidth && this.state.windowWidth > W ? { maxHeight: p.height } : {},
        wrapperCssClass: w(
          "k-list-content",
          {
            "k-list-scroller": !a
          }
        ),
        listStyle: i.enabled ? { transform: v } : void 0,
        key: "listkey",
        skip: c,
        onClick: this.handleItemClick,
        itemRender: n,
        groupHeaderItemRender: l,
        noDataRender: o,
        onMouseDown: (b) => b.preventDefault(),
        onScroll: this.onScroll,
        wrapperRef: i.scrollerRef,
        scroller: this.base.renderScrollElement(),
        ariaSetSize: a.total
      }
    );
  }
  renderSearchBar(s, e, t) {
    const {
      tabIndex: o,
      disabled: n,
      dataItemKey: l,
      virtual: a = { skip: 0 }
    } = this.props, r = y(this.props), p = this.props.opened !== void 0 ? this.props.opened : this.state.opened, i = this.value, c = Math.max(0, r.findIndex((d) => C(d, i, l)));
    return this._suggested && !C(this._valueOnDidUpdate, i, l) && (this._suggested = ""), /* @__PURE__ */ h.createElement(
      ue,
      {
        id: e,
        readOnly: p && this.mobileMode,
        placeholder: t,
        tabIndex: o,
        title: this.props.title,
        accessKey: this.props.accessKey,
        value: s + this._suggested,
        suggestedText: this._suggested,
        ref: (d) => this._input = d && d.input,
        onClick: this.onInputClick,
        onKeyDown: this.onInputKeyDown,
        onChange: this.inputOnChange,
        onFocus: this.base.handleFocus,
        onBlur: this.handleBlur,
        disabled: n,
        expanded: p,
        owns: this.base.listBoxId,
        activedescendant: `option-${this.base.guid}-${c + a.skip}`,
        role: "combobox",
        ariaLabelledBy: this.props.ariaLabelledBy,
        ariaLabel: this.props.ariaLabel,
        ariaDescribedBy: this.props.ariaDescribedBy,
        ariaRequired: this.required,
        render: this.props.valueRender
      }
    );
  }
  clearValue() {
    const s = this.base.initState();
    this._suggested = "", this.navigationIndex = void 0, this.base.filterChanged("", s), this.props.filter === void 0 && this.state.text !== void 0 && (s.data.text = void 0), this.triggerOnChange(null, s);
    const e = this.props.opened !== void 0 ? this.props.opened : this.state.opened, t = this.mobileMode;
    e && !t && this.base.togglePopup(s), this.applyState(s);
  }
  triggerOnChange(s, e) {
    const t = this.value;
    !this.hasDuplicates && (!S(t) && !S(s) || C(t, s, this.props.dataItemKey)) || (this.props.value === void 0 && (e.data.value = s), this._valueDuringOnChange = s, e.events.push({ type: "onChange" }));
  }
  getFocusedIndex(s) {
    const e = this.value, { textField: t, dataItemKey: o, virtual: n = { skip: 0 }, focusedItemIndex: l = K, skipDisabledItems: a } = this.props, r = y(this.props), p = this.props.filter ? this.props.filter : this.state.text;
    return s && this.navigationIndex !== void 0 ? this.navigationIndex : S(e) && p === void 0 ? r.findIndex((i) => C(i, e, o)) : p ? l(r, p, t) : a && t && !p && n.skip === 0 ? r.findIndex((i) => !i.disabled && i[t]) : n.skip === 0 ? 0 : -1;
  }
  suggestValue(s) {
    const { data: e, textField: t } = this.props;
    this._suggested = ce(s, e, t);
  }
  applyState(s) {
    this.base.applyState(s), this._valueDuringOnChange = void 0;
  }
  calculateMedia(s) {
    for (const e of s)
      this.setState({ windowWidth: e.target.clientWidth });
  }
};
E.displayName = "ComboBox", E.propTypes = {
  ...B.propTypes,
  size: m.oneOf([null, "small", "medium", "large"]),
  rounded: m.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: m.oneOf([null, "solid", "flat", "outline"]),
  dataItemKey: m.string,
  groupField: m.string,
  groupMode: m.oneOf([void 0, "classic", "modern"]),
  isMultiColumn: m.bool,
  suggest: m.bool,
  placeholder: m.string,
  title: m.string,
  allowCustom: m.bool,
  clearButton: m.bool,
  iconClassName: m.string,
  svgIcon: oe,
  validationMessage: m.string,
  required: m.bool,
  id: m.string,
  ariaLabelledBy: m.string,
  ariaLabel: m.string,
  ariaDescribedBy: m.string,
  list: m.any,
  valueRender: m.func,
  skipDisabledItems: m.bool
}, E.defaultProps = {
  ...B.defaultProps,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  allowCustom: !1,
  clearButton: !0,
  required: !1,
  groupMode: "modern",
  isMultiColumn: !1,
  skipDisabledItems: !0,
  prefix: void 0,
  suffix: void 0
};
let T = E;
const Ee = ne(), we = le(re(Ee, T));
we.displayName = "KendoReactComboBox";
export {
  we as ComboBox,
  Ee as ComboBoxPropsContext,
  T as ComboBoxWithoutContext
};
