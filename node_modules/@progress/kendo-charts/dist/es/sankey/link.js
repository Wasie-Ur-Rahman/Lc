import { drawing } from '@progress/kendo-drawing';
import { SankeyElement } from './element';
import { deepExtend } from '../common';
import { defined } from '../drawing-utils';
import { ARIA_ACTIVE_DESCENDANT } from '../common/constants';

var distanceToLine = function (line, point) {
    var ref = line[0];
    var x1 = ref[0];
    var y1 = ref[1];
    var ref$1 = line[1];
    var x2 = ref$1[0];
    var y2 = ref$1[1];
    var x3 = point[0];
    var y3 = point[1];

    return Math.abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / Math.sqrt(Math.pow( (x2 - x1), 2 ) + Math.pow( (y2 - y1), 2 ));
};

var bezierPoint = function (p1, p2, p3, p4, t) {
    var t1 = 1 - t;
    var t1t1 = t1 * t1;
    var tt = t * t;
    return (p1 * t1t1 * t1) + (3 * p2 * t * t1t1) + (3 * p3 * tt * t1) + (p4 * tt * t);
};

var angelBetweenTwoLines = function (line1, line2) {
    var ref = line1[0];
    var x1 = ref[0];
    var y1 = ref[1];
    var ref$1 = line1[1];
    var x2 = ref$1[0];
    var y2 = ref$1[1];
    var ref$2 = line2[0];
    var x3 = ref$2[0];
    var y3 = ref$2[1];
    var ref$3 = line2[1];
    var x4 = ref$3[0];
    var y4 = ref$3[1];

    var a1 = Math.atan2(y2 - y1, x2 - x1);
    var a2 = Math.atan2(y4 - y3, x4 - x3);

    return Math.abs(a1 - a2);
};

var calculateControlPointsOffsetX = function (link, rtl) {
    var x0 = link.x0;
    var x1 = link.x1;
    var y0 = link.y0;
    var y1 = link.y1;
    var xC = (x0 + x1) / 2;

    var width = link.width;
    var halfWidth = width / 2;

    // upper curve, t = 0.5
    var upperCurveMiddleLine = [[(x0 + xC) / 2, y0 - halfWidth], [(x1 + xC) / 2, y1 - halfWidth]];

    // for lower curve, bezier-point at t = 0.5
    // for the case t = 0.5, the bezier-point is the middle point of the curve. => ((y0 + halfWidth) + (y1 + halfWidth)) / 2
    var lowerCurveMiddlePoint = [xC, bezierPoint(y0 + halfWidth, y0 + halfWidth, y1 + halfWidth, y1 + halfWidth, 0.5)];

    // The actual width of the link at its middle point as can be seen on the screen.
    var actualWidth = distanceToLine(upperCurveMiddleLine, lowerCurveMiddlePoint);

    var upperNarrowness = (width - actualWidth) / 2;

    // The line `upperCurveMiddleLine` shows the upper border of the link.
    // Assumption 1: Translated to the left to the desired link width and the translate value will be the `offset`.
    // Assumption 2: The translate value is a hypotenuse of a triangle.
    var alpha = angelBetweenTwoLines(upperCurveMiddleLine, [[x0, y0 - halfWidth], [xC, y0 - halfWidth]]);
    var a = upperNarrowness;
    var b = Math.sin(alpha) * a;
    var offset = Math.sqrt(a * a + b * b);
    // Another option is to assume the triangle is isosceles
    // => offset = Math.sqrt(2) * upperNarrowness;

    var sign = y0 - y1 > 0 ? (-1) : 1;
    if (rtl) {
        sign = -sign;
    }

    return sign * offset;
};

export var Link = (function (SankeyElement) {
    function Link () {
        SankeyElement.apply(this, arguments);
    }

    if ( SankeyElement ) Link.__proto__ = SankeyElement;
    Link.prototype = Object.create( SankeyElement && SankeyElement.prototype );
    Link.prototype.constructor = Link;

    Link.prototype.getElement = function getElement () {
        var link = this.options.link;
        var x0 = link.x0;
        var x1 = link.x1;
        var y0 = link.y0;
        var y1 = link.y1;
        var xC = (x0 + x1) / 2;

        return new drawing.Path(this.visualOptions())
            .moveTo(x0, y0).curveTo([xC, y0], [xC, y1], [x1, y1]);
    };

    Link.prototype.getLabelText = function getLabelText (options) {
        var labelTemplate = options.labels.ariaTemplate;

        if (labelTemplate) {
            return labelTemplate({ link: options.link });
        }
    };

    Link.prototype.visualOptions = function visualOptions () {
        var options = this.options;
        var link = this.options.link;
        var ariaLabel = this.getLabelText(options);

        return {
            stroke: {
                width: options.link.width,
                color: link.color || options.color,
                opacity: defined(link.opacity) ? link.opacity : options.opacity
            },
            role: 'graphics-symbol',
            ariaRoleDescription: 'Link',
            ariaLabel: ariaLabel
        };
    };

    Link.prototype.createFocusHighlight = function createFocusHighlight () {
        if (!this.options.navigatable) {
            return;
        }
        var ref = this.options;
        var link = ref.link;
        var rtl = ref.rtl;
        var x0 = link.x0;
        var x1 = link.x1;
        var y0 = link.y0;
        var y1 = link.y1;
        var xC = (x0 + x1) / 2;
        var halfWidth = link.width / 2;

        var offset = calculateControlPointsOffsetX(link, rtl);

        this._highlight = new drawing.Path({ stroke: this.options.focusHighlight, visible: false })
            .moveTo(x0, y0 + halfWidth)
            .lineTo(x0, y0 - halfWidth)
            .curveTo([xC + offset, y0 - halfWidth], [xC + offset, y1 - halfWidth], [x1, y1 - halfWidth])
            .lineTo(x1, y1 + halfWidth)
            .curveTo([xC - offset, y1 + halfWidth], [xC - offset, y0 + halfWidth], [x0, y0 + halfWidth]);
    };

    Link.prototype.focus = function focus (options) {
        if (this._highlight) {
            var ref = options || {};
            var highlight = ref.highlight; if ( highlight === void 0 ) highlight = true;
            if (highlight) {
                this._highlight.options.set('visible', true);
            }
            var id = (this.options.link.sourceId) + "->" + (this.options.link.targetId);
            this.visual.options.set('id', id);

            if (this.options.root()) {
                this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
            }
        }
    };

    Link.prototype.blur = function blur () {
        if (this._highlight) {
            this._highlight.options.set('visible', false);
            this.visual.options.set('id', '');

            if (this.options.root()) {
                this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
            }
        }
    };

    return Link;
}(SankeyElement));

export var resolveLinkOptions = function (link, options, sourceNode, targetNode) {
    var linkOptions = deepExtend({},
        options,
        {
            link: link,
            opacity: link.opacity,
            color: link.color,
            colorType: link.colorType,
            visual: link.visual,
            highlight: link.highlight
        }
    );

    if (linkOptions.colorType === 'source') {
        linkOptions.color = sourceNode.options.fill.color;
    } else if (linkOptions.colorType === 'target') {
        linkOptions.color = targetNode.options.fill.color;
    }

    return linkOptions;
};
